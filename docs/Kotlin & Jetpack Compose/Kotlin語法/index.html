<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.6">
<title data-react-helmet="true">Kotlin 語法 | Hello</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://milk88101524.github.io/milk88101524/my-note/docs/Kotlin &amp; Jetpack Compose/Kotlin語法"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="Kotlin 語法 | Hello"><meta data-react-helmet="true" name="description" content="---"><meta data-react-helmet="true" property="og:description" content="---"><link data-react-helmet="true" rel="shortcut icon" href="/my-note/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://milk88101524.github.io/milk88101524/my-note/docs/Kotlin &amp; Jetpack Compose/Kotlin語法"><link data-react-helmet="true" rel="alternate" href="https://milk88101524.github.io/milk88101524/my-note/docs/Kotlin &amp; Jetpack Compose/Kotlin語法" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://milk88101524.github.io/milk88101524/my-note/docs/Kotlin &amp; Jetpack Compose/Kotlin語法" hreflang="x-default"><link rel="stylesheet" href="/my-note/assets/css/styles.f446caee.css">
<link rel="preload" href="/my-note/assets/js/runtime~main.76aea1a5.js" as="script">
<link rel="preload" href="/my-note/assets/js/main.23de69b3.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_OuoZ">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/my-note/"><b class="navbar__title">Han 的學習日記</b></a><a class="navbar__item navbar__link navbar__link--active" href="/my-note/docs/intro">Tutorial</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/milk88101524/" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_wgqa"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="react-toggle toggle_2i4l react-toggle--disabled"><div class="react-toggle-track" role="button" tabindex="-1"><div class="react-toggle-track-check"><span class="toggle_iYfV">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_iYfV">🌞</span></div><div class="react-toggle-thumb"></div></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_lDyR"><button class="clean-btn backToTopButton_i9tI" type="button"><svg viewBox="0 0 24 24" width="28"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z" fill="currentColor"></path></svg></button><aside class="docSidebarContainer_0YBq"><div class="sidebar_a3j0"><nav class="menu thin-scrollbar menu_cyFh menuWithAnnouncementBar_+O1J"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" href="/my-note/docs/intro">Tutorial Intro</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Tutorial - Basics</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Tutorial - Extras</a></li><li class="theme-doc-sidebar-item-category menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#">Tutorial - Kotlin &amp; Compose</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/my-note/docs/Kotlin &amp; Jetpack Compose/Kotlin語法">Kotlin 語法</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/my-note/docs/Kotlin &amp; Jetpack Compose/JetpackComposeNote1">啥是 Jetpack Compose</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/my-note/docs/Kotlin &amp; Jetpack Compose/JetpackComposeNote2">Jetpack Compose 工具介紹</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/my-note/docs/Kotlin &amp; Jetpack Compose/JetpackComposeNote3">Composable</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/my-note/docs/Kotlin &amp; Jetpack Compose/JetpackComposeNote4">() -&gt; Unit 與 @Composable () -&gt; Unit</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/my-note/docs/Kotlin &amp; Jetpack Compose/JetpackComposeNote5">狀態管理</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/my-note/docs/Kotlin &amp; Jetpack Compose/JetpackComposeNote6">Navigation</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/my-note/docs/Kotlin &amp; Jetpack Compose/JetpackComposeNote7">Compose 實現 MVP 與 MVVM 架構</a></li></ul></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Tutorial - Java Script</a></li></ul></nav></div></aside><main class="docMainContainer_r8cw"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_zHA2"><div class="docItemContainer_oiyr"><article><div class="tocCollapsible_aw-L theme-doc-toc-mobile tocMobile_Tx6Y"><button type="button" class="clean-btn tocCollapsibleButton_zr6a">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>Kotlin 語法</h1></header><hr><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="1-變數宣告"></a>1. 變數宣告<a class="hash-link" href="#1-變數宣告" title="Direct link to heading">#</a></h2><p>var: 該變數可改變
val: 如同JAVA 中的final 該變數不可改變</p><p><code>var/val variableName: Type = value</code>
var 用於聲明一個可變的變數，而 val 用於聲明一個不可變的變數（相當於 Java 中的 final）
variableName 是變數的名稱
Type 是變數的數據類型，可以使用顯式類型聲明（如 String、Int、Double 等）或者省略，讓 Kotlin透過上下文自動推斷類型
value 是變數的初始值</p><p>因此，在 Kotlin 中，你是在變數後面使用 : 來指定類型，而不是在前面</p><blockquote><p>關鍵字、自動推倒，要注意幾點：
var 類型推導完成後，不可再賦予其他類型
val 必須賦予值，並且不能再對其變量進行更改，否則編譯器會提是 Val cannot be reassigned 錯誤   </p><p>自動推導並非每次都有用，若是我們對一個變量延遲賦值，Kotlin 就無法自動推倒其類型，這時可以使用 : 指定
// lateinit 延遲初始化，就必須指定參數類型
lateinit var name: String
Kotlin 內所的事物皆為對象，也就是 沒有基礎數據類型 (其實也就是將 Java 每一個數據類型開頭改為大寫)</p></blockquote><table><thead><tr><th align="center">Java 基礎數據類型</th><th align="center">Kotlin 對象數據類型</th></tr></thead><tbody><tr><td align="center">boolean</td><td align="center">Boolean</td></tr><tr><td align="center">char</td><td align="center">Char</td></tr><tr><td align="center">byte</td><td align="center">Byte</td></tr><tr><td align="center">short</td><td align="center">Short</td></tr><tr><td align="center">int</td><td align="center">Int</td></tr><tr><td align="center">long</td><td align="center">Long</td></tr><tr><td align="center">float</td><td align="center">Float</td></tr><tr><td align="center">double</td><td align="center">Double</td></tr></tbody></table><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="2-ifelse--whenjave的switch-判斷"></a>2. if/else &amp; when(jave的switch) 判斷<a class="hash-link" href="#2-ifelse--whenjave的switch-判斷" title="Direct link to heading">#</a></h2><p>if 與 Java 不同的使用地方，其最大的不同在於 Kotlin 的 if 可以直接返回數值，並且不需要 return 關鍵字</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="ifelse-判斷"></a>if/else 判斷<a class="hash-link" href="#ifelse-判斷" title="Direct link to heading">#</a></h3><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">fun main() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    var a : String = &quot;Hello&quot;;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    val b : String = &quot;World&quot;;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    println(&quot;Like Java: &quot; + diffTextLikeJava(a, b));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    println(&quot;Kotlin: &quot; + diffTextKotlin(a, b));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">// Kotlin&#x27;s if 可使用如同 Java&#x27;s if</span></span><span class="token-line" style="color:#393A34"><span class="token plain">fun diffTextLikeJava(text1 : String, text2 : String) : String {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (text1 == text2) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return &quot;true&quot;;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return &quot;false&quot;;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">// Kotlin&#x27;s if 可以有返回值!!</span></span><span class="token-line" style="color:#393A34"><span class="token plain">// 該返回值在代碼中的最後一行 (不須 return</span></span><span class="token-line" style="color:#393A34"><span class="token plain">fun diffTextKotlin (text1 : String, text2 : String) : String {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return if(text1 == text2) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        &quot;true&quot;;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        &quot;false&quot;;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">fun useIfSimple(n1: Int, n2: Int) = if (n1 &gt; n2) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    &quot;$n1 is Bigger&quot;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">} else {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    &quot;$n2 is Bigger&quot;  // return 不可以用在 = 符號</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>在 Kotlin 中，如果函式的主體只包含一個表達式，你可以使用單行表達式來定義函式，這種方式通常適用於簡單的函式。在你提供的程式碼中，
useIfSimple 函式就是一個單行表達式的例子。</p><p>這是如何工作的：</p><p><code>fun useIfSimple(n1: Int, n2: Int)</code>
這是定義函式的開始，
宣告了函式名稱、參數和返回值類型（在這裡省略了返回值類型，Kotlin 可以根據表達式的結果自動推斷）。</p><p>=：這表示函式的主體將是一個表達式</p><p><code>if (n1 &gt; n2) { &quot;$n1 is Bigger&quot; } else { &quot;$n2 is Bigger&quot; }：</code>
這就是函式的主體。它是一個 if-else 表達式，根據條件的結果，返回不同的值。</p><p>因此，使用 = 後面接 if-else 表達式是 Kotlin 中定義單行表達式函式的一種方式，使得程式碼更簡潔易讀。</p><p>when 作為取代 switch 的關鍵字，並且 Kotlin 對其功能進行了拓展，</p><p>可以搭配 is 使用在類的判斷相當於 java instanceof(取代 case，並 省略了 break 關鍵字)，</p><p>並且最後使用 else (取代 default)，</p><p>when 語句如同 if 是可以有返回值</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="when-代替-switch"></a>when 代替 switch<a class="hash-link" href="#when-代替-switch" title="Direct link to heading">#</a></h3><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">fun useWhenSimple(id: Int) = when(id) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    1 -&gt; &quot;A&quot;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    2 -&gt; {  // 超過一行時使用大括號</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        &quot;B&quot;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    3 -&gt; &quot;C&quot;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    else -&gt; &quot;Non&quot;   // like default</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">// when 可以配合 is 一起使用，相當於 Java 的 instanceof</span></span><span class="token-line" style="color:#393A34"><span class="token plain">fun useIs(id: Number) : Unit = when(id) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    is Int -&gt; println(&quot;Params is Int&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    is Double -&gt; println(&quot;Params is Double&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    is Float -&gt; println(&quot;Params is Float&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    else -&gt; println(&quot;Cannot decide Type&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">// 若要直接使用參數判斷，when 就不需要括弧，並且可以 對關鍵字進行操作</span></span><span class="token-line" style="color:#393A34"><span class="token plain">fun useWhenWithParams(id: Number) = when {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    id is Byte -&gt; println(&quot;Params is Int&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    id == 11 -&gt; println(&quot;Params is 11&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    id == 11.1 -&gt; println(&quot;Params is 11.1&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    id.toFloat() == 1.0f -&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        println(&quot;Params is 1.0f&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    else -&gt; println(&quot;Cannot decide Type&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p> <code>==</code> 符號在 Java 中是用來判斷兩個內存地址是否相同，而Kotlin <code>==</code> 符號則是判斷對象、字串是否相同，相當於equals的方法</p><table><thead><tr><th align="center">功能</th><th align="center">Java關鍵字</th><th align="center">Kotlin關鍵字</th></tr></thead><tbody><tr><td align="center">對象是否相等(內容)</td><td align="center">equals</td><td align="center">==</td></tr><tr><td align="center">內存（記憶體）地址是否相等</td><td align="center">==</td><td align="center">===</td></tr></tbody></table><blockquote><p>Kotlin 語法不支持 Java 中的三元運算符 <code>?:</code>，但可以使用 Kotlin 提供的 <code>if</code> 表達式來實現相同的效果。可以直接用 <code>if</code> 表達式來處理條件邏輯</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">condition ? value_if_true : value_if_false;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>這是 Java 中的三元運算符
在 Kotlin 實現三元運算符</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">if (condition) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    value_if_true</span></span><span class="token-line" style="color:#393A34"><span class="token plain">} else {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    value_if_false</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div></blockquote><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="3-循環--區間---語法糖"></a>3. 循環 &amp; 區間 - 語法糖<a class="hash-link" href="#3-循環--區間---語法糖" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="array-陣列"></a>Array 陣列<a class="hash-link" href="#array-陣列" title="Direct link to heading">#</a></h3><p>陣列的宣告</p><ul><li><p>一般宣告型態方式</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">var array: IntArray = intArrayOf(1, 2, 3)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div></li><li><p>不需要宣告型態了, 因為後面都已經把型態標示出來, 就可以節省一些資訊</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">var array = intArrayOf(1,2,3)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div></li><li><p>宣告各種型態的陣列</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">var iArray = intArrayOf(1, 2, 3)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">var fArray = floatArrayOf(1.0f, 2.0f, 3.0f)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">var bArray = booleanArrayOf(true, false, true)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">var cArray = charArrayOf(&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div></li><li><p>透過建構子傳入想要傳入的個數</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">var iArray = IntArray(3)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">iArray[0] = 4</span></span><span class="token-line" style="color:#393A34"><span class="token plain">iArray[1] = 1</span></span><span class="token-line" style="color:#393A34"><span class="token plain">iArray[2] = 7</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div></li><li><p>字串陣列，不是 stringArrayOf 宣告, 須透過 arrayOf 這個方法來進行宣告</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">var sArray = arrayOf(&quot;abc&quot;, &quot;def&quot;, &quot;ght&quot;)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="for-迴圈"></a>for 迴圈<a class="hash-link" href="#for-迴圈" title="Direct link to heading">#</a></h3><ol><li><p>for 迴圈取得整個陣列全部值 <code>item &gt; for(item in xxxArray)</code></p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">var iArray = intArrayOf(1, 2, 3)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">var sArray = arrayOf(&quot;abc&quot;, &quot;def&quot;, &quot;ght&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">for(item in iArray){</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    print(&quot;$item &quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">結果：1 2 3</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">for(item in sArray){</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    print(&quot;$item &quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">結果：abc def ght</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div></li><li><p>for 迴圈取得索引值 <code>indices &gt; for (i in xxxArray.indices)</code></p></li></ol><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">for (i in iArray.indices) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    println(&quot;${iArray[i]}&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><blockquote><p>array 的 indices 方法就是拿出索引值 透過存取 ${xxxArray[i]} 來存取到陣列內的值</p><p>為什麼大括弧來包覆呢? 因為它必須透過 xxxArray 的 index 去存取值, 屬於運算的部分, 因此須透過大括弧包覆才能取到值, 否則只會取到 iArray[i] 所對應的位址而已</p></blockquote><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_y2LR" id="語法糖"></a>語法糖<a class="hash-link" href="#語法糖" title="Direct link to heading">#</a></h4><p>Kotlin 語言的特色之一，就是它有提供一系列優秀的「語法糖」，可以 有利於開發速度、可讀性！以下是 Kotlin 常用的 循環 &amp; 區間 的關鍵字</p><p>在 Kotlin 中，帶有 ? 的參數表示它是可為 null 的（nullable）。這意味著你可以將這些參數設置為 null，並且函式的實現需要處理這些參數為 null 的情況。</p><table><thead><tr><th align="center">關鍵字(符號)</th><th align="left">功能</th></tr></thead><tbody><tr><td align="center">until</td><td align="left">同樣是個區間，但是不包含最後一個元素 (左閉右開)</td></tr><tr><td align="center">in</td><td align="left">判斷是否符合在區間內，會配合著 .. 一起使用 (類似 Python)</td></tr><tr><td align="center">..</td><td align="left">區間，包含最後一個數字 (until 則不包含)</td></tr><tr><td align="center">step</td><td align="left">前進的數量</td></tr><tr><td align="center">downTo</td><td align="left">前面都是升序，downTo 則是降序讀取</td></tr></tbody></table><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">fun main() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    println(&quot;3 in 0..10: ${3 in 0..10}&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 0..10 表示的是一個從 0 到 10（包含 0 和 10）的範圍，這個範圍包含了所有從 0 到 10 的整數</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    println(&quot;3 in 0..10 step 2: ${3 in 0..10 step 2}&quot;)    // false</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 0..10 step 2 表示的是以步長 2 遍歷的範圍，從 0 開始，每次增加 2，直到 10。換句話說，它會產生序列 0, 2, 4, 6, 8, 10</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    println(&quot;3 in 0..10 step 3: ${3 in 0..10 step 3}&quot;)    // true</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 10 downTo 0 step 3 表示的是以步長 3 遍歷的範圍，從 10 開始，每次減少 3，直到 0。換句話說，它會產生序列 10, 7, 4, 1。</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    println(&quot;4 in 10 downTo 0 step 3: ${4 in 10 downTo 0 step 3}&quot;)    // true</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">// 若以java來表示為 : for (int i=0; i&lt;=5; i++) {}</span></span><span class="token-line" style="color:#393A34"><span class="token plain">fun useForIn() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (i in 0 .. 5) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        println(&quot;$i&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">// 若以java來表示為 : for (int i=0; i&lt;=5; i=i+2) {}</span></span><span class="token-line" style="color:#393A34"><span class="token plain">fun useForInStep() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (i in 0 .. 5 step 2) {  // 一次前進 2</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        println(&quot;Step: $i&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">// 達成左閉右開</span></span><span class="token-line" style="color:#393A34"><span class="token plain">// 若以java來表示為 : for (int i=0; i&lt;5; i++) {}</span></span><span class="token-line" style="color:#393A34"><span class="token plain">fun useForInUntil() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (i in 0 until 5) {  // 當然可以與 step 結合 (0 ~ 4)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        println(&quot;until: $i&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">// 區間 `..` &amp; Until 都是 &quot;升序&quot;，downTo 則是降序</span></span><span class="token-line" style="color:#393A34"><span class="token plain">// 若以java來表示為 : for (int i=5; i &gt;=0; i=+2) {}</span></span><span class="token-line" style="color:#393A34"><span class="token plain">fun useForInDownTo() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (i in 5 downTo 0 step 2) {    // 區間 [10,0]，並配合 step 使用</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        println(&quot;downTo: $i&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">// 指定次數的 For 迴圈會使用 in + until</span></span><span class="token-line" style="color:#393A34"><span class="token plain">fun forControl(times : Int = 10) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (i in 0 until times) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // TODO:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="4-companion-object"></a>4. Companion object<a class="hash-link" href="#4-companion-object" title="Direct link to heading">#</a></h2><p>在 Kotlin 中，<code>companion object</code> 是一種特殊的對象，它用來在類中實現類似靜態方法和靜態屬性的功能。以下是 <code>companion object</code> 的一些關鍵點：</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="什麼是-companion-object"></a>什麼是 <code>companion object</code>？<a class="hash-link" href="#什麼是-companion-object" title="Direct link to heading">#</a></h3><ol><li>靜態方法和屬性：<ul><li>在 Java 中，靜態方法和屬性是直接與類相關聯的，並且可以通過類名直接訪問。Kotlin 沒有靜態方法和靜態屬性的概念，而是使用 <code>companion object</code> 來達到類似的效果</li></ul></li><li>定義方式：<ul><li><code>companion object</code> 是在類內部定義的一個單例對象。可以在 <code>companion object</code> 中定義屬性和方法，這些屬性和方法可以通過類名直接訪問</li></ul></li><li>唯一實例：<ul><li><code>companion object</code> 在類中只有一個實例。這個對象在第一次被引用時會被創建，並且在整個應用程序生命週期內保持唯一</li></ul></li><li>訪問方式：<ul><li>可以通過類名來訪問 <code>companion object</code> 的方法和屬性，而不需要創建類的實例</li></ul></li></ol><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="範例"></a>範例<a class="hash-link" href="#範例" title="Direct link to heading">#</a></h3><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">class MyClass {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 定義 companion object</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    companion object {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 靜態屬性</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        val staticProperty: String = &quot;Static Property&quot;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 靜態方法</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        fun staticMethod() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            println(&quot;This is a static method&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">fun main() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 訪問 companion object 的靜態屬性和方法</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    println(MyClass.staticProperty) // 輸出: Static Property</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    MyClass.staticMethod() // 輸出: This is a static method</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="詳細解釋"></a>詳細解釋<a class="hash-link" href="#詳細解釋" title="Direct link to heading">#</a></h3><ol><li>靜態屬性和方法： 在上述範例中，<code>staticProperty</code> 和 <code>staticMethod</code> 是 <code>companion object</code> 中定義的靜態屬性和方法。可以通過 <code>MyClass.staticProperty</code> 和 <code>MyClass.staticMethod()</code> 直接訪問它們，而不需要創建 <code>MyClass</code> 的實例</li><li>用於工廠方法： <code>companion object</code> 常用於實現工廠方法模式。例如，可以使用 <code>companion object</code> 提供靜態的工廠方法來創建類的實例：</li></ol><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">class User private constructor(val name: String) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    companion object {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        fun create(name: String): User {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return User(name)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">fun main() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    val user = User.create(&quot;John&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    println(user.name) // 輸出: John</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ol start="3"><li>訪問伴生對象的名稱： 可以選擇為 <code>companion object</code> 指定名稱，但如果沒有指定名稱，它默認被稱為 <code>Companion</code>。例如：</li></ol><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">class MyClass {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    companion object Factory {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        fun create(): MyClass {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return MyClass()</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>這裡，<code>companion object</code> 被命名為 <code>Factory</code>，可以通過 <code>MyClass.Factory.create()</code> 訪問它的方法</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="小結"></a>小結<a class="hash-link" href="#小結" title="Direct link to heading">#</a></h3><p><code>companion object</code> 使得在 Kotlin 中可以實現靜態方法和屬性的功能，並且為類提供了一個可以訪問靜態成員的方式。它的唯一實例特性使得它非常適合用於那些只需要一個實例的情況，比如工廠方法和靜態常量</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="5-function--method"></a>5. Function / Method<a class="hash-link" href="#5-function--method" title="Direct link to heading">#</a></h2><p>在 Kotlin 中，函數（Function）是非常核心的一部分，因為它們支持函數式編程風格，並且是 Kotlin 語言設計的基礎。以下是關於 Kotlin 中函數的一些詳細說明</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="基本函數"></a>基本函數<a class="hash-link" href="#基本函數" title="Direct link to heading">#</a></h3><ol><li><p>函數的定義
函數定義的基本語法如下：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">fun functionName(parameter1: Type1, parameter2: Type2): ReturnType {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 函數體</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return value</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>例如：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">fun add(a: Int, b: Int): Int {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return a + b</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>在這個例子中，<code>add</code> 函數接受兩個 <code>Int</code> 類型的參數，並返回它們的和</p></li><li><p>單表達式函數
如果函數體只有一行，Kotlin 允許你使用單表達式函數的簡化語法：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">fun add(a: Int, b: Int): Int = a + b</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>使用 <code>=</code> 符號來表示函數的返回值，這樣可以讓函數更簡潔</p></li><li><p>預設參數
Kotlin 函數可以有預設值，這使得在呼叫函數時可以省略某些參數：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">fun greet(name: String = &quot;Guest&quot;) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    println(&quot;Hello, $name!&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">greet()          // 輸出: Hello, Guest!</span></span><span class="token-line" style="color:#393A34"><span class="token plain">greet(&quot;Alice&quot;)   // 輸出: Hello, Alice!</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div></li><li><p>命名參數
當函數有多個參數時，你可以使用命名參數來提高函數調用的可讀性：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">fun createUser(name: String, age: Int) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    println(&quot;Name: $name, Age: $age&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">createUser(age = 25, name = &quot;Bob&quot;)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>這樣可以讓你在調用函數時不必按照參數的順序傳遞值</p></li><li><p>可變參數
Kotlin 允許函數接受可變數量的參數（varargs）</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">fun printNumbers(vararg numbers: Int) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (number in numbers) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        println(number)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">printNumbers(1, 2, 3, 4, 5)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p><code>vararg</code> 使得 <code>numbers</code> 成為一個 <code>Int</code> 類型的數組，可以接受任意數量的參數</p></li></ol><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="高階函數"></a>高階函數<a class="hash-link" href="#高階函數" title="Direct link to heading">#</a></h3><ol><li><p>將函數作為參數
Kotlin 支持高階函數，即函數可以接受其他函數作為參數：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">fun performOperation(a: Int, b: Int, operation: (Int, Int) -&gt; Int): Int {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return operation(a, b)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">val result = performOperation(5, 3, ::add)  // 使用函數引用</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(result)  // 輸出: 8</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>在這個例子中，<code>performOperation</code> 函數接受一個 <code>operation</code> 函數，這個函數接受兩個 <code>Int</code> 類型的參數並返回一個 <code>Int</code> 類型的結果</p></li><li><p>返回函數
Kotlin 也支持函數返回其他函數：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">fun multiplier(factor: Int): (Int) -&gt; Int {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return { number -&gt; number * factor }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">val timesTwo = multiplier(2)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(timesTwo(5))  // 輸出: 10</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p><code>multiplier</code> 函數返回一個函數，這個返回的函數將其輸入乘以 <code>factor</code></p></li></ol><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="擴展函數"></a>擴展函數<a class="hash-link" href="#擴展函數" title="Direct link to heading">#</a></h3><ol><li><p>擴展函數
Kotlin 允許為現有的類型添加新函數，而不需要修改它們的源代碼：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">fun String.lastChar(): Char = this[this.length - 1]</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(&quot;Kotlin&quot;.lastChar())  // 輸出: n</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>這裡 <code>lastChar</code> 函數被添加到了 <code>String</code> 類型上，但實際上不會修改 <code>String</code> 類的源代碼</p></li></ol><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="匿名函數和-lambda-表達式"></a>匿名函數和 lambda 表達式<a class="hash-link" href="#匿名函數和-lambda-表達式" title="Direct link to heading">#</a></h3><ol><li><p>匿名函數
Kotlin 支持匿名函數，即沒有名稱的函數：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">val greet = fun(name: String) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    println(&quot;Hello, $name!&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">greet(&quot;World&quot;)  // 輸出: Hello, World!</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div></li><li><p>lambda 表達式
Lambda 表達式是 Kotlin 中的另一種匿名函數表達方式：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">val add = { a: Int, b: Int -&gt; a + b }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(add(5, 3))  // 輸出: 8</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>Lambda 表達式可以省略返回類型，並且語法更加簡潔</p></li></ol><h3>::</h3><p><code>::</code> 是 Kotlin 中的「函數引用」運算符，它用來取得某個函數或屬性的引用。在 Kotlin 中，函數可以作為一級對象處理，這意味著你可以將函數作為變數、參數或返回值。<code>::</code> 運算符可以讓你更方便地取得這些函數的引用</p><ol><li><p>取得函數引用
使用 <code>::</code> 可以取得某個函數的引用，這樣可以將函數當作變數或參數傳遞。這裡有個例子：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">fun greet(name: String) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    println(&quot;Hello, $name!&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">val greetFunction = ::greet</span></span><span class="token-line" style="color:#393A34"><span class="token plain">greetFunction(&quot;World&quot;)  // 輸出: Hello, World!</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>在這個例子中，<code>::greet</code> 是 <code>greet</code> 函數的引用，<code>greetFunction</code> 變數可以用來調用 <code>greet</code> 函數</p></li><li><p>函數作為參數
函數引用可以作為其他函數的參數傳遞。這在需要高階函數的情況下特別有用：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">fun executeFunction(action: (String) -&gt; Unit, value: String) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    action(value)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">executeFunction(::greet, &quot;Kotlin&quot;)  // 輸出: Hello, Kotlin!</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>這裡，<code>::greet</code> 代表了 <code>greet</code> 函數，並被傳遞到 <code>executeFunction</code> 函數中</p></li><li><p>取得屬性引用
<code>::</code> 也可以用來取得屬性的引用。這樣你可以用來訪問或修改屬性：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">class Person(val name: String)</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">val nameProperty = Person::name</span></span><span class="token-line" style="color:#393A34"><span class="token plain">val person = Person(&quot;Alice&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(nameProperty.get(person))  // 輸出: Alice</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>在這個例子中，<code>Person::name</code> 是 <code>name</code> 屬性的引用，並可以用 <code>get</code> 函數來讀取屬性的值</p></li><li><p>擴展函數和伴生對象
<code>::</code> 也可以用來引用擴展函數和伴生對象的函數：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">fun String.printLength() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    println(this.length)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">val printLengthFunction = String::printLength</span></span><span class="token-line" style="color:#393A34"><span class="token plain">&quot;Hello&quot;.printLengthFunction()  // 輸出: 5</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>這裡，<code>String::printLength</code> 是 <code>printLength</code> 擴展函數的引用，可以用來調用該函數</p></li></ol><blockquote><ul><li><code>::</code> 運算符用於取得函數或屬性的引用</li><li>它能夠讓你更靈活地操作函數和屬性，並在高階函數和其他場景中使用</li><li>使用函數引用可以使代碼更加簡潔，並提供了更多的靈活性</li></ul></blockquote><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="kotlin-中的-model-類別"></a>Kotlin 中的 Model 類別<a class="hash-link" href="#kotlin-中的-model-類別" title="Direct link to heading">#</a></h2><p>在 Kotlin 中，模型類別通常使用 <code>data class</code> 來簡化代碼。<code>data class</code> 是 Kotlin 特有的語法，用於自動生成很多樣板代碼，如 <code>equals()</code>, <code>hashCode()</code>, 和 <code>toString()</code> 方法。</p><ol><li>屬性（Properties）:<ul><li>可以使用 <code>var</code>（可變）或 <code>val</code>（不可變）來定義屬性</li><li>屬性自動生成 getter 和 setter 方法（如果是 <code>var</code> 的話）</li></ul></li><li>主構造函數（Primary Constructor）:<ul><li>定義類別的屬性和初始化邏輯</li><li>主構造函數可以直接在類別定義中聲明，並在 <code>data class</code> 中自動生成許多常見方法</li></ul></li><li>自動生成的方法:<ul><li><code>equals()</code>, <code>hashCode()</code>, 和 <code>toString()</code> 方法由 <code>data class</code> 自動生成</li></ul></li></ol><p>Kotlin 示例</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">data class User(</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    val name: String,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    val age: Int</span></span><span class="token-line" style="color:#393A34"><span class="token plain">)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><blockquote><p>Kotlin 是從 Java 優化來的，那來講講 Kotlin 跟 Java 在 Model 中的差異</p><p>那先從講解 Java Model 開始</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="java-中的模型類別"></a>Java 中的模型類別<a class="hash-link" href="#java-中的模型類別" title="Direct link to heading">#</a></h3><p>在 Java 中，模型類別通常是用來表示應用中的數據結構。這些類別通常包含：</p><ol><li>私有屬性（Private Fields）:<ul><li>用於存儲數據</li><li>通常會使用 <code>private</code> 修飾符來保護這些屬性</li></ul></li><li>公共 getter 和 setter 方法（Getters and Setters）: <ul><li>提供對私有屬性的訪問和修改方法</li><li>每個屬性通常都有對應的 <code>get</code> 和 <code>set</code> 方法</li></ul></li><li>構造函數（Constructors）: <ul><li>用於初始化對象</li><li>通常會提供至少一個構造函數</li></ul></li><li><code>equals()</code>, <code>hashCode()</code>, 和 <code>toString()</code> 方法: <ul><li>用於比較對象、生成哈希碼和生成對象的字符串表示</li></ul></li></ol><p>而 Java 與 Kotlin 的 Model 有下列幾點差異</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="1-語法簡潔性"></a>1. 語法簡潔性<a class="hash-link" href="#1-語法簡潔性" title="Direct link to heading">#</a></h3><ul><li>Java: 在 Java 中，通常需要寫大量的樣板代碼來創建一個模型類別，例如 getter 和 setter 方法、<code>equals()</code>, <code>hashCode()</code>, 和 <code>toString()</code> 方法等    </li><li>Kotlin: Kotlin 提供了更簡潔的語法來定義模型類別，特別是使用 <code>data class</code> 來自動生成很多樣板代碼</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="2-自動生成方法"></a>2. 自動生成方法<a class="hash-link" href="#2-自動生成方法" title="Direct link to heading">#</a></h3><ul><li>Java: 在 Java 中，你需要手動編寫 <code>equals()</code>, <code>hashCode()</code>, 和 <code>toString()</code> 方法，這些方法是用來比較對象、生成哈希碼和打印對象的字符串表示形式</li><li>Kotlin: 使用 <code>data class</code> 可以自動生成 <code>equals()</code>, <code>hashCode()</code>, 和 <code>toString()</code> 方法，並且可以通過主構造函數中的屬性自動生成這些方法所需的內容</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="3-不可變性immutable"></a>3. 不可變性（Immutable）<a class="hash-link" href="#3-不可變性immutable" title="Direct link to heading">#</a></h3><ul><li>Java: 默認情況下，Java 中的對象是可變的，雖然你可以通過只提供 getter 方法而不提供 setter 方法來實現不可變性，但這樣做需要手動編寫代碼 </li><li>Kotlin: 使用 <code>val</code> 定義的屬性是不可變的（即只讀），這意味著它們在初始化後不能被修改。這種語法使得不可變對象的創建變得更簡單</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="4-主構造函數和次構造函數"></a>4. 主構造函數和次構造函數<a class="hash-link" href="#4-主構造函數和次構造函數" title="Direct link to heading">#</a></h3><ul><li>Java: 在 Java 中，類通常有一個或多個構造函數來初始化對象</li><li>Kotlin: Kotlin 提供了主構造函數，可以在 <code>data class</code> 中直接定義屬性，並且可以使用次構造函數進行擴展 </li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="5-擴展函數"></a>5. 擴展函數<a class="hash-link" href="#5-擴展函數" title="Direct link to heading">#</a></h3><ul><li>Kotlin: Kotlin 允許你為現有類添加新方法，而不需要修改類的源代碼。這稱為擴展函數（extension functions）</li></ul></blockquote></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/my-note/docs/tutorial-extras/translate-your-site"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« Translate your site</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/my-note/docs/Kotlin &amp; Jetpack Compose/JetpackComposeNote1"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">啥是 Jetpack Compose »</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_vrFS thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#1-變數宣告" class="table-of-contents__link">1. 變數宣告</a></li><li><a href="#2-ifelse--whenjave的switch-判斷" class="table-of-contents__link">2. if/else &amp; when(jave的switch) 判斷</a><ul><li><a href="#ifelse-判斷" class="table-of-contents__link">if/else 判斷</a></li><li><a href="#when-代替-switch" class="table-of-contents__link">when 代替 switch</a></li></ul></li><li><a href="#3-循環--區間---語法糖" class="table-of-contents__link">3. 循環 &amp; 區間 - 語法糖</a><ul><li><a href="#array-陣列" class="table-of-contents__link">Array 陣列</a></li><li><a href="#for-迴圈" class="table-of-contents__link">for 迴圈</a></li></ul></li><li><a href="#4-companion-object" class="table-of-contents__link">4. Companion object</a><ul><li><a href="#什麼是-companion-object" class="table-of-contents__link">什麼是 <code>companion object</code>？</a></li><li><a href="#範例" class="table-of-contents__link">範例</a></li><li><a href="#詳細解釋" class="table-of-contents__link">詳細解釋</a></li><li><a href="#小結" class="table-of-contents__link">小結</a></li></ul></li><li><a href="#5-function--method" class="table-of-contents__link">5. Function / Method</a><ul><li><a href="#基本函數" class="table-of-contents__link">基本函數</a></li><li><a href="#高階函數" class="table-of-contents__link">高階函數</a></li><li><a href="#擴展函數" class="table-of-contents__link">擴展函數</a></li><li><a href="#匿名函數和-lambda-表達式" class="table-of-contents__link">匿名函數和 lambda 表達式</a></li><li><a href="#" class="table-of-contents__link">::</a></li></ul></li><li><a href="#kotlin-中的-model-類別" class="table-of-contents__link">Kotlin 中的 Model 類別</a></li></ul></div></div></div></div></main></div></div></div>
<script src="/my-note/assets/js/runtime~main.76aea1a5.js"></script>
<script src="/my-note/assets/js/main.23de69b3.js"></script>
</body>
</html>